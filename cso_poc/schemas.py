"""
Layer 4 — Canonical Intent Envelope & Domain Models

The Intent Envelope is the deterministic artifact produced by the CSO's
reasoning pass.  It is never generated by agent negotiation; it is the
single authoritative instruction set for execution.
"""

from __future__ import annotations

import uuid
from datetime import datetime
from enum import Enum
from typing import Any

from pydantic import BaseModel, Field


# ---------------------------------------------------------------------------
# Domain value objects
# ---------------------------------------------------------------------------

class LoyaltyTier(str, Enum):
    MEMBER = "Member"
    SILVER = "Silver"
    GOLD = "Gold"
    PLATINUM = "Platinum"
    DIAMOND = "Diamond"
    TITANIUM = "Titanium"


class BenefitType(str, Enum):
    SUITE_NIGHT_AWARD = "SuiteNightAward"
    LATE_CHECKOUT = "LateCheckout"
    POINTS_BONUS = "PointsBonus"
    COMPLIMENTARY_BREAKFAST = "ComplimentaryBreakfast"
    COMPLIMENTARY_DRINK_VOUCHER = "ComplimentaryDrinkVoucher"


class GuestProfile(BaseModel):
    """Resource model returned by guest://profile/{id}."""
    guest_id: str
    name: str
    loyalty_tier: LoyaltyTier
    preferences: dict[str, Any] = Field(default_factory=dict)
    current_stay: StayInfo | None = None
    stays: list[StayInfo] = Field(default_factory=list)


class StayInfo(BaseModel):
    reservation_id: str
    property_code: str
    room_number: str
    check_in: datetime
    check_out: datetime
    notes: str = ""


# Pydantic v2 forward-ref resolution
GuestProfile.model_rebuild()


# ---------------------------------------------------------------------------
# MCP tool parameter schemas (strict JSON-schema enforcement)
# ---------------------------------------------------------------------------

class PmsUpdateReservationParams(BaseModel):
    res_id: str = Field(..., description="Reservation identifier in the PMS")
    checkout_time: datetime = Field(..., description="Requested new checkout datetime")
    notes: str = Field("", description="Free-text operational notes")


class PmsUpdateCheckinParams(BaseModel):
    res_id: str = Field(..., description="Reservation identifier in the PMS")
    checkin_time: datetime = Field(..., description="Requested new check-in datetime")
    notes: str = Field("", description="Free-text operational notes")


class LoyaltyAllocateBenefitParams(BaseModel):
    guest_id: str = Field(..., description="Loyalty programme member ID")
    benefit_type: BenefitType = Field(..., description="Benefit to allocate")


class RoomReassignmentParams(BaseModel):
    res_id: str = Field(..., description="Reservation identifier")
    new_room_number: str = Field(..., description="Target room number")
    reason: str = Field(..., description="Reason for reassignment")
    notes: str = Field("", description="Additional operational notes")


# ---------------------------------------------------------------------------
# Layer 4 — Canonical Intent Envelope
# ---------------------------------------------------------------------------

class EnvelopeStatus(str, Enum):
    """Overall disposition of the intent after CSO reasoning."""
    EXECUTABLE = "Executable"
    PARTIAL_FULFILLMENT = "Partial_Fulfillment"
    HUMAN_ESCALATION_REQUIRED = "Human_Escalation_Required"
    REJECTED = "Rejected"


class ContextualAssertion(BaseModel):
    """
    A structured fact or finding the CSO records during reasoning.

    Unlike plain domain_assertions (simple confirmed facts), these carry
    a domain tag and severity so downstream systems can route them.
    """
    domain: str = Field(
        ..., description="Capability domain (e.g. 'PMS', 'Loyalty', 'Provisions')",
    )
    assertion: str = Field(
        ..., description="What the CSO determined",
    )
    requires_escalation: bool = Field(
        False, description="True if no MCP tool can resolve this",
    )


class ProposedAction(BaseModel):
    """A single deterministic MCP tool call in the execution plan."""
    tool_name: str = Field(..., description="Fully-qualified MCP tool name")
    parameters: dict[str, Any] = Field(
        default_factory=dict,
        description="Arguments matching the tool's JSON schema",
    )
    order: int = Field(..., description="Execution sequence index (0-based)")
    idempotency_key: str = Field(
        default_factory=lambda: uuid.uuid4().hex,
        description="Client-generated key for safe retries",
    )
    is_compromise: bool = Field(
        False,
        description="True if this action is a fallback/compromise for an "
                    "unfulfillable original request",
    )
    compromise_rationale: str = Field(
        "",
        description="Why the CSO chose this compromise over the original ask",
    )


class CanonicalIntentEnvelope(BaseModel):
    """
    The single authoritative output of the CSO reasoning pass.

    No agent-to-agent negotiation — the CSO produces this envelope,
    and the Orchestrator executes it deterministically via MCP calls.
    """
    intent_id: str = Field(
        default_factory=lambda: str(uuid.uuid4()),
        description="Unique trace ID for this reasoning artifact",
    )
    timestamp: datetime = Field(
        default_factory=datetime.utcnow,
        description="UTC time the envelope was created",
    )
    primary_objective: str = Field(
        ...,
        description="Plain-language goal (e.g. 'Extend checkout to 4 PM for Diamond guest')",
    )
    status: EnvelopeStatus = Field(
        EnvelopeStatus.EXECUTABLE,
        description="Overall disposition after reasoning",
    )
    domain_assertions: list[str] = Field(
        default_factory=list,
        description="Simple confirmed facts",
    )
    contextual_assertions: list[ContextualAssertion] = Field(
        default_factory=list,
        description="Structured findings, including escalation flags",
    )
    proposed_actions: list[ProposedAction] = Field(
        default_factory=list,
        description="Ordered sequence of MCP tool calls to execute",
    )
    escalation_notes: list[str] = Field(
        default_factory=list,
        description="Human-readable notes for staff when escalation is required",
    )


# ---------------------------------------------------------------------------
# Decision Breadcrumb (Layer 6)
# ---------------------------------------------------------------------------

class DecisionBreadcrumb(BaseModel):
    """Immutable audit record for a single MCP tool execution."""
    trace_id: str
    policy_reference: str
    action_taken: str
    result: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    latency_ms: float = Field(default=0.0, description="Wall-clock latency of the tool call in milliseconds")

    def format_log_line(self) -> str:
        line = (
            f"[{self.trace_id}] | "
            f"[{self.policy_reference}] | "
            f"[{self.action_taken}] | "
            f"[{self.result}]"
        )
        if self.latency_ms > 0:
            line += f" ({self.latency_ms:.0f}ms)"
        return line
